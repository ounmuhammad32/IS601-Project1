{% extends "base.html" %}
{% block content %}
    <img src="{{ url_for('static', filename='images/SOLIDbanner.png') }}" class="img-fluid" alt="SOLIDbanner">
    <div class="row align-items-center">
        <div class="col-6 py-4">
            <img src="{{ url_for('static', filename='images/s.png') }}"
                 class="img-fluid"
                 alt="s">
        </div>
        <div class="col-6 py-4">
            <p class="fs-20">Each class shall be responsible for only one single concept. In calculator, classes such as
                addition, subtraction, multiplication and division all have one and only one function.
                In other words, every component of your code (in general a class, but also a function) should have one
                and only one responsibility. As a consequence of that, there should be only a reason to change it.

            </p>
        </div>
    </div>

    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>

        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/o.png') }}"
                 class="img-fluid"
                 alt="o">
        </div>
        <div class="col-6 pb-4">
            <p class="fs-20">You should not need to modify the code you have already written to accommodate new
                functionality, but simply add what you now need. If we were to add new function to our calculator
                for example square root, we only need to add Squareroot class that will automatically inherit from
                Calculation class.
                The newly formed sub-class will be immediately picked up by __subclasses__() and no modification in
                any other part of the code needs to happen.
                The result is a very flexible class, that requires minimum time to be maintained.

            </p>
        </div>
    </div>

    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/l.png') }}"
                 class="img-fluid"
                 alt="l">
        </div>
        <div class="col-6 pb-4">
            <p class="fs-20">If a subclass redefines a function also present in the parent class, a client-user
                should not be noticing any difference in behaviour, and it is a substitute for the base class.
                For example, if you are using a function and your colleague change the base class, you should
                not notice any difference in the function that you are using. For this principle, there is no
                standard “template-like” solution where it must be applied, and it is hard to offer a “standard
                example” to showcase.
                The child class extends the behavior of its parent, but never narrows it down. In our calculator
                Child Classes are
                inheriting from the parent "Calculation" and each have their own "get_result():" methods,
                which operate in similarly expected ways without interfering with each other or the
                parent.

            </p>
        </div>
    </div>


    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/i.png') }}"
                 class="img-fluid"
                 alt="i">
        </div>
        <div class="col-6 pb-4">
            <p class="fs-20">In the contest of classes, an interface is considered, all the methods and
                properties “exposed”, thus, everything that a user can interact with that belongs to that
                class.
                In this sense, the IS principles tell us that a class should only have the interface needed
                (SRP) and avoid methods that won’t work or that have no reason to be part of that class.
                This problem arises, primarily, when, a subclass inherits methods from a base class that it
                does not need.
            </p>
        </div>
    </div>

    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/d.png') }}"
                 class="img-fluid"
                 alt="d">
        </div>
        <div class="col-6 pb-4">
            <p class="fs-20">Dependency should be on abstractions not concretions. High-level modules
                should not depend upon low-level modules. Both low and high level classes should depend
                on the same abstractions. Abstractions should not depend on details. Details should
                depend upon abstractions.
                I our calculator each method is separate and does not depend on the low-level module. For example
                "get_last_calculation_object" and the "get_last_calculation_result_value" depend on the
                class that they fall under.
            </p>
        </div>
    </div>



    <h1 class="b2 pt-5"></h1>
    <h4 class="neonblue mt-4"><u>Design Patters</u></h4>️ ️
    <div class="row align-items-start">
        <div class="col-8">
            <p class="fs-20">
                <span class="fs-3">I</span>n software engineering, a design pattern is a general repeatable solution to
                a
                commonly occurring problem
                in software design. A design pattern isn't a finished design that can be transformed directly into code.
                It
                is a description or template for how to solve a problem that can be used in many different situations.
                Design patterns are typical solutions to commonly occurring problems in software design. They are like
                pre-made blueprints that you can customize to solve a recurring design problem in your code.

                You can’t just find a pattern and copy it into your program, the way you can with off-the-shelf
                functions or
                libraries. The pattern is not a specific piece of code, but a general concept for solving a particular
                problem. You can follow the pattern details and implement a solution that suits the realities of your
                own
                program.

                Patterns are often confused with algorithms, because both concepts describe typical solutions to some
                known
                problems. While an algorithm always defines a clear set of actions that can achieve some goal, a pattern
                is
                a more high-level description of a solution. The code of the same pattern applied to two different
                programs
                may be different.

                An analogy to an algorithm is a cooking recipe: both have clear steps to achieve a goal. On the other
                hand,
                a pattern is more like a blueprint: you can see what the result and its features are, but the exact
                order of
                implementation is up to you.
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/designpat.png') }}"
                 class="img-fluid"
                 alt="designpat">
        </div>
    </div>
    <h1 class="b1"></h1>
    <div class="row justify-content-center py-4">
        <div class="col-2"></div>
        <div class="col-8">
            <img src="{{ url_for('static', filename='images/typesofpatterns.png') }}"
                 class="img-fluid"
                 alt="typesofpatterns">
        </div>
        <div class="col-2"></div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/beh.png') }}"
                 class="img-fluid"
                 alt="beh">
        </div>
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Behavioral Patterns</u></h4>️ ️
            <p class="fs-20">
                <span class="fs-3">B</span>ehavioral patterns describe interactions between objects and focus on how
                objects communicate with each other. They can reduce complex flow charts to mere interconnections
                between
                objects of various classes. Behavioral patterns are also used to make the algorithm that a class uses
                simply
                another parameter that is adjustable at runtime. Behavioral patterns are concerned with algorithms and
                the
                assignment of responsibilities between objects. Behavioral patterns describe not just patterns of
                objects or
                classes but also the patterns of communication between them.
                These patterns characterize complex control flow that is difficult to follow at run-time. They shift
                your
                focus away from the flow of control to let you concentrate just on the way objects are interconnected.
                Behavioral class patterns use inheritance to distribute behavior between classes.
                The Template Method is the simpler and more common of the two. A template method is an abstract
                definition
                of an algorithm. It defines the algorithm step by step. Each step invokes either an abstract operation
                or a
                primitive operation. A subclass fleshes out the algorithm by defining the abstract operations. The other
                behavioral class pattern is Interpreter pattern, which represents a grammar as a class hierarchy and
                implements an interpreter as an operation on instances of these classes.
            </p>
        </div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/createpat.png') }}"
                 class="img-fluid"
                 alt="createpat">
        </div>
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Creational Patterns</u></h4>️ ️
            <p class="fs-20">
                <span class="fs-3">C</span>reational patterns are used to create objects for a suitable class that
                serves as a solution for a problem. Generally when instances of several different classes are available.
                They are particularly useful when you are taking advantage of polymorphism and need to choose between
                different classes at runtime rather than compile time.

                Creational patterns support the creation of objects in a system. Creational patterns allow objects to be
                created in a system without having to identify a specific class type in the code, so you do not have to
                write large, complex code to instantiate an object. It does this by having the subclass of the class
                create the objects. However, this can limit the type or number of objects that can be created within a
                system.
            </p>
        </div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/structpattern.png') }}"
                 class="img-fluid"
                 alt="structpattern">
        </div>
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Structural Patterns</u></h4>️ ️
            <p class="fs-20">
                <span class="fs-3">S</span>tructural patterns form larger structures from individual parts, generally
                of different classes.
                Structural patterns vary a great deal depending on what sort of structure is being created for what
                purpose.

                Structural patterns are concerned with how classes and objects are composed to form larger structures.
                Structural class patterns use inheritance to compose interfaces or implementations. As a simple example,
                consider how multiple inheritance mixes two or more classes into one. The result is a class that
                combines the properties of its parent classes. This pattern is particularly useful for making
                independently developed class libraries work together.
                Another example is the class form of the Adapter Pattern.
                In general, an adapter makes one interface (the adaptee's) conform to another, thereby providing a
                uniform abstraction of different interfaces. A class adapter accomplishes this by inheriting privately
                from an adaptee class. The adapter then expresses its interface in terms of the adaptee's.
            </p>
        </div>
    </div>



    <h1 class="b1 pt-5"></h1>
    <p class="fs-14">Resources:
    <ul class="fs-14">
        <li>
            <a href="https://towardsdatascience.com/solid-coding-in-python-1281392a6a94"
               class="card-link darkgrey" target="_blank">SOLID</a>
        </li>
        <li>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde"
               class="card-link darkgrey" target="_blank">Dependency Inversion</a>
        </li>
        <li>
            <a href="https://refactoring.guru/design-patterns/what-is-pattern"
               class="card-link darkgrey" target="_blank">Design Patterns</a>
        </li>
        <li>
            <a href="https://www.gofpatterns.com/design-patterns/module2/three-types-design-patterns.php"
               class="card-link darkgrey" target="_blank">Design Patterns</a>
        </li>

    </ul>
    </div>
    </div>
{% endblock %}