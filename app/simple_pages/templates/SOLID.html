{% extends "base.html" %}
{% block content %}
    <h3 class="neonblue mt-4"><u>SOLID Principles</u></h3>️
    <div class="row align-items-center">
        <div class="col-8 py-4">
            <p class="fs-20">
                The SOLID Principles are five principles of Object-Oriented class design.
                They are a set of rules and best practices to follow while designing a class structure.
                These five principles help us understand the need for certain design patterns and software architecture
                in
                general.
                So I believe that it is a topic that every developer should learn.
            </p>
            <p class="fs-20">
            <ul>
                <li>The Single Responsibility Principle</li>
                <li>The Open-Closed Principle</li>
                <li>The Liskov Substitution Principle</li>
                <li>The Interface Segregation Principle</li>
                <li>The Dependency Inversion Principle</li>
            </ul>
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/solid.png') }}"
                 class="img-fluid"
                 alt="designpat">
        </div>
    </div>
    <div class="row align-items-center">
        <div class="col-8 py-4">
            <p class="fs-20">
            <h4>Single Responsibility Principle</h4>
            The Single Responsibility Principle states that a class should do one thing and therefore
            A class should have one and only one reason to change, meaning that a class should have only one job.
            For Example In calculator, classes such as addition, subtraction, multiplication and division can be
            handeled by one function.

            </p>
            <h4>Open-Closed Principle</h4>
            <p class="fs-20">You should not need to modify the code you have already written to accommodate new
                functionality, but simply add what you now need. If we were to add new function to our calculator
                for example square root, we only need to add Squareroot class that will automatically inherit from
                Calculation class.
                The newly formed sub-class will be immediately picked up by __subclasses__() and no modification in
                any other part of the code needs to happen.
                The result is a very flexible class, that requires minimum time to be maintained.

            </p>
            <h4>Liskov Substitution Principle</h4>
            <p class="fs-20">If a subclass redefines a function also present in the parent class, a client-user
                should not be noticing any difference in behaviour, and it is a substitute for the base class.
                For example, if you are using a function and your colleague change the base class, you should
                not notice any difference in the function that you are using. For this principle, there is no
                standard “template-like” solution where it must be applied, and it is hard to offer a “standard
                example” to showcase.
                The child class extends the behavior of its parent, but never narrows it down. In our calculator
                Child Classes are
                inheriting from the parent "Calculation" and each have their own "get_result():" methods,
                which operate in similarly expected ways without interfering with each other or the
                parent.

            </p>
            <h4>Interface Segregation Principle</h4>
            <p class="fs-20">In the contest of classes, an interface is considered, all the methods and
                properties “exposed”, thus, everything that a user can interact with that belongs to that
                class.
                In this sense, the IS principles tell us that a class should only have the interface needed
                (SRP) and avoid methods that won’t work or that have no reason to be part of that class.
                This problem arises, primarily, when, a subclass inherits methods from a base class that it
                does not need.
            </p>
            <h4>Dependency Inversion Principle</h4>
            <p class="fs-20">Dependency should be on abstractions not concretions. High-level modules
                should not depend upon low-level modules. Both low and high level classes should depend
                on the same abstractions. Abstractions should not depend on details. Details should
                depend upon abstractions.
                I our calculator each method is separate and does not depend on the low-level module. For example
                "get_last_calculation_object" and the "get_last_calculation_result_value" depend on the
                class that they fall under.
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/solid1.png') }}"
                 class="img-fluid"
                 alt="designpat">
        </div>
    </div>
    <div class="row align-items-center">
        <h3 class="neonblue mt-4"><u>Design Patters</u></h3>️ ️
        <div class="row align-items-start">
            <div class="col-8 py-4">
                <p class="fs-20">
                    Design patterns represent the best practices used by experienced object-oriented software
                    developers. Design patterns are solutions to general problems that software developers faced during
                    software development. These solutions were obtained by trial and error by numerous software
                    developers over quite a substantial period of time. Design patterns provide a standard terminology
                    and are specific to particular scenario. For example, a singleton design pattern signifies use of
                    single object so all developers familiar with single design pattern will make use of single object
                    and they can tell each other that program is following a singleton pattern.
                <h4>Creational Patterns</h4>
                Provide an interface for creating families of related or dependent objects without specifying their
                concrete classes.
                Separate the construction of a complex object from its representation, allowing the same construction
                process to create various representations.
                A class accepts the objects it requires from an injector instead of creating the objects directly.
                Define an interface for creating a single object, but let subclasses decide which class to instantiate.
                Factory Method lets a class defer instantiation to subclasses.
                Ensure a class has only named instances, and provide a global point of access to them.
                Specify the kinds of objects to create using a prototypical instance, and create new objects from the
                'skeleton' of an existing object, thus boosting performance and keeping memory footprints to a minimum.
                <h4>Structural Patterns</h4>
                Convert the interface of a class into another interface clients expect. An adapter lets classes work
                together that could not otherwise because of incompatible interfaces. The enterprise integration pattern
                equivalent is the translator.
                Decouple an abstraction from its implementation allowing the two to vary independently.
                Composite Compose objects into tree structures to represent part-whole hierarchies. Composite lets
                clients treat individual objects and compositions of objects uniformly.
                Decorator Attach additional responsibilities to an object dynamically keeping the same interface.
                Decorators provide a flexible alternative to subclassing for extending functionality.
                Facade Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level
                interface that makes the subsystem easier to use.
                Flyweight Use sharing to support large numbers of similar objects efficiently.
                <h4>Behavioral Patterns</h4>
                Artificial intelligence pattern for combining disparate sources of data
                Chain of responsibility Avoid coupling the sender of a request to its receiver by giving more than one
                object a chance to handle the request. Chain the receiving objects and pass the request along the chain
                until an object handles it.
                Command Encapsulate a request as an object, thereby allowing for the parameterization of clients with
                different requests, and the queuing or logging of requests. It also allows for the support of undoable
                operations.
                Interpreter Given a language, define a representation for its grammar along with an interpreter that
                uses the representation to interpret sentences in the language.
                Iterator Provide a way to access the elements of an aggregate object sequentially without exposing its
                underlying representation.
                Mediator Define an object that encapsulates how a set of objects interact. Mediator promotes loose
                coupling by keeping objects from referring to each other explicitly, and it allows their interaction to
                vary independently.
                Memento Without violating encapsulation, capture and externalize an object's internal state allowing the
                object to be restored to this state later.
                Null object Avoid null references by providing a default object.

                </p>
            </div>
            <div class="col-4 py-4">
                <img src="{{ url_for('static', filename='images/dp.png') }}"
                     class="img-fluid"
                     alt="designpat">
            </div>
        </div>


        <h1 class="b1 pt-5"></h1>
        <p class="fs-14">Resources:
        <ul class="fs-14">
            <li>
                <a href="https://www.freecodecamp.org/news/solid-principles-explained-in-plain-english/"
                   class="card-link darkgrey" target="_blank">SOLID</a>
            </li>

            <li>
                <a href="https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm"
                   class="card-link darkgrey" target="_blank">Design Patterns</a>
            </li>

        </ul>
    </div>
    </div>
{% endblock %}